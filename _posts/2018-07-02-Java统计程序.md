---
t
itle:  "Java程序-统计一首诗里哪个字出现的次数最多"
toc: true
permalink: /tech/java-shushu
tag: 技术
excerpt: "可变长度的数组-容器，排序和编码等"
last_modified_at: 2018-07-02T08:06:00-05:00
typora-copy-images-to: ..\assets\images
---

统计的这首诗叫做《长恨歌》，白居易写的七言诗，有关唐明皇和杨玉环的爱情故事。我用了4个早上把它背了下来。里面失眠的描写我写过一篇小小的博文：[白居易说失眠]({% post_url  2018-06-15-失眠 %})

[TOC]

# 按照故事的情节我把这首诗分为5个部分

| 故事情节                     | 包含多少句 | 总计             |
| ---------------------------- | ---------- | ---------------- |
| 相恋：最美的女人，最高的宠爱 | 15句       | 60句，一句14个字 |
| 死别：战乱起，美人抵罪       | 13句       | 共840个字        |
| 魂念：君王挂念，夜不成眠     | 9          |                  |
| 寻访：仙山画卷中的人         | 13         |                  |
| 寄词：也许某天会再见         | 10         |                  |

在背诵的过程中，我发现“春”这个字重复出现了很多次，我想知道具体的数值，但不想自己数，于是想到用Java写个小程序来统计。

# 程序最终的效果

~~~java
//共有多少字数
total：840

//不同的汉字共有多少个
different_total：700

//汉字按照出现的次数多少，从大到小进行排列
'春' ：10
'君'	：9 
'人'	：6
'六'	：2
~~~

# 设计思路

- 编辑器：Intellij IDEA

  - 一些快捷键的应用 Alt+Enter：智能提示，Ctrl+Alt+L：代码自动排版;Alt+Insert+Fn(联想小新要加Fn)，自动插入构造函数等

- 数据结构：容器

  ![pic2](../assets/images/07022.png)

  

  - 容器里面用得比较熟悉的就是ArrayList，有序可重复，在后面进行添加
  - 每个汉字要带上一个计数器，首先想到字典的键值对 `{key:value},{汉字：次数}`，python里叫字典，Java里叫Map，容器的一种。
  - 容器我的理解就是数组的扩展，容器的大小是可变的，数组不行。
  - 分别用ArrayList和HashMap进行实现

- 排序算法：二分、冒泡算法选择，性能扩展，如果是84万字呢

# 问题分解

将这个任务从简单到复杂逐步迭代。

## 程序直接给出一串字符串，统计每个字母出现次数

~~~java
String  str="caabab";

//共有多少字符数
total：6

//不同的字母有多少个
different_total：3

//结果
'a' : 3
'b' : 2
'c' : 1
~~~

### 思考：

1. 虽然在这里str的长度是固定的，不过要把这个长度想象成非常长，不能人工数出来的那种长。

2. 总数就是字符串的长度。

3. 不同的字母有多少个，要计算种类的个数。

4. 结果的展现，表明要对重复的次数进行记录，一个字母要有一个计数器。

   1. 首先，这个结果是要存在某个数据里，不能仅仅只是打印出来。

   2. 方案1是使用面向对象思考，比如可以建一个类，叫做TypeChar，里面的两个成员变量，一个是char，一个是int，创建对象时就初始化字符和次数。

   3. 将这个有计数器的对象加入到列表里。需查看ArrayList的[Java API文档](%http://tool.oschina.net/apidocs/apidoc?api=jdk-zh%),它是在java.util包里。

      > 我第一次写的时候很笨，是把26个字母先全部添加到arraylist里， 作为str里字符比较的基础。比如说str里第一个字符是'a', 就遍历arraylist，'a'就在第一个，不再遍历了，把列表里'a'的计数器增1
      >
      > //重复26次，很有点笨，比较好的方法是每遍历到一个新的字母，就把这个字母赋值到对象的char属性，然后把这个对象加入到列表里来
      >
      > TypeChar a=new TyprChar('a',0)；
      >
      > arraylist.add(a);
      >
      > TypeChar b=new TyprChar('b',0)；
      >
      > arraylist.add(b);

      ![pic1](../assets/images/07021.png)

      ~~~java
       public static void main(String[] args) {
              ArrayList arrayList = new ArrayList();
              //test(arraylist);
              String str = "caabab";
              System.out.println("total: "+str.length());
              for (int i = 0; i < str.length(); i++) {
                  char ch = str.charAt(i);
                  //判断列表中是否存在这个字母
                  if (charInList(ch, arrayList)) {
                      //存在，则将它的计数加1
                      chAddCount(ch, arrayList);
                  } else {
                      //不存在，就把它加入到这个列表中
                      arrayList.add(new TypeChar(ch, 1));
                  }
      
              }
              System.out.println("different_total: "+arrayList.size());
           	//排序
              sort(arrayList);
              //打印
              print(arrayList);
          }
      --------------    
      //结果
      total: 6
      different_total: 3
      a:3
      b:2
      c:1
      ~~~

      ~~~java
      public static class TypeChar {
              char typeCh;
              int count;
      
              public TypeChar(char typeCh, int count) {
                  this.typeCh = typeCh;
                  this.count = count;
              }
      
              @Override
              public String toString() {
                  return typeCh + ":" + count;
              }
      
              public void setTypeCh(char typeCh) {
                  this.typeCh = typeCh;
              }
      
              public void setCount(int count) {
                  this.count = count;
              }
      
              public char getTypeCh() {
                  return typeCh;
              }
      
              public int getCount() {
                  return count;
              }
          }
      
          static void test(ArrayList arrayList) {
              arrayList.add(new TypeChar('z', 2));
              arrayList.add(new TypeChar('x', 4));
              print(arrayList);
          }
      
          //判断该字母是否存在于当前列表
          static boolean charInList(char ch, ArrayList arrayList) {
              int i = arrayList.size();
              for (int j = 0; j < i; j++) {
                  TypeChar tc = (TypeChar) arrayList.get(j);
                  if (ch == tc.getTypeCh()) {
                      return true;
                  }
              }
              return false;
          }
      
          //将该字母在列表里的计数加1
          static void chAddCount(char ch, ArrayList arrayList) {
              int i = arrayList.size();
              for (int j = 0; j < i; j++) {
                  TypeChar tc = (TypeChar) arrayList.get(j);
                  if (ch == tc.getTypeCh()) {
                      int newCount = tc.getCount() + 1;
                      tc.setCount(newCount);
                  }
              }
          }
      
          static class SortByCount implements Comparator {
              @Override
              public int compare(Object o1, Object o2) {
                  TypeChar s1 = (TypeChar) o1;
                  TypeChar s2 = (TypeChar) o2;
                  if (s1.getCount() > s2.getCount())
                      return -1;
                  return 1;
              }
          }
      
      
      
          //将列表按照计数大小，从大到小进行排列
          static void sort(ArrayList arrayList) {
              int i = arrayList.size();
              Collections.sort(arrayList, new SortByCount());
      
          }
      
          //将列表打印出来，每个字母对应一个计数
          static void print(ArrayList arrayList) {
              Iterator i = arrayList.iterator();
              while (i.hasNext()) {
                  //TypeChar tc= (TypeChar)i.next();
                  //System.out.println(tc.toString());
                  System.out.println(i.next());
              }
      
      
          }
      ~~~

      ### 代码中涉及到的知识点

      | 知识点                                                       | 疑问                                                         |
      | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | 要读字符串中的单个字符，使用str.charAt(索引)，索引从0开始，将str看作一个一元数组 | 字符串最后一位是\0吗 不是 String str = "abc";等效于： char data[] = {'a', 'b', 'c'}; String str = new String(data); |
      | ArrayList是一个类，它实现了List接口（List实现了Collection接口），可以用a.get(索引)来取列表中这个索引位置的元素，类型是Object | List和Collection的方法包括哪些                               |
      | 元素取出来后进行转型，这个例子里是这样：TypeChar  tc= (TyprChar)a.get(0) | String s= (String)i;不可行                                   |
      | 类的构造，包括有参构造、toString()重写，Getter()、Setter()，fn+alt+insert快捷键 | 打印一个类时，调用了toString()                               |
      | test(arraylist)，是为了测试能否将一个字符直接作为对象的一个字段打包放进列表里 |                                                              |
      | print(arraylist),把列表里的元素按照a:3这样的格式打印，先是取出这个元素，再用类的toString()重写打印方法 |                                                              |
      | Iterator是一个游标，初始化后类似于指针，指向列表的第一个元素，i.next()取出这个元素 | 这里奇怪不用进行转型就能知道是TypeChar类的元素，可它只能调用toString()方法，其他类里的方法调不到 |
      | charInList(arraylist),判断一个字母是否在这个列表中，那么首先要把列表里的元素类中的字段值取出来，就用到了arraylist.get(索引)——>转型成TypeChar——>取出字段值 | 可以替代Iterator的一种方法                                   |
      | charAddCount(arraylist)，如果这个字母存在，则计数加1，同上一个函数很多重复，就是在取出元素的计数后，加1，再把更新后的计数放进去。 |                                                              |

      | 比较器                                                       | 难点                                                         |
      | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | collections有一个sort(list,Comparator())方法，方法中的参数，一个是列表，一个是比较器 | Collections是啥，和Collection（接口）容器是什么关系？见下，Collections这个类里的方法特别多，sort()只是其中之一 |
      | 比较器自己写，也就是写一个类实现Comparator接口，重写里面的int compare(o1,o2)方法，返回一个整数 -1或1，大到小或者小到大 | 这就排好序了？具体过程是什么?                                |

      > **概念区分：** **java.util.Collection和java.util.Collections区别：**
      >
      >  
      >
      > 1、  java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java  类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
      >
      >  
      >
      > 2、java.util.Collections  是一个包装类（工具类/帮助类）。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。

      | 运行中错误                                                   | 解决                                                         |
      | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | 没有分文件，都写在一个Java文件里，在执行函数main()之上写类还有那些方法时，总是提示Error:(119, 9) java: 无法从静态上下文中引用非静态 方法 sort(java.util.ArrayList) | 必须要在这些方法前加上static关键字。static的作用是指在编译时就将类加载到方法区，有没有声明对象都不影响。 |
      | 静态上下文的理解，这个函数是在main()中调用的，因为main是static的，所以它包含的方法和类也必须得是static的 | 以前没有这个问题，怎么回事                                   |
      | 列表越界错误，在for循环中arraylist.get(l)索引写成了长度，一是不会发生遍历，而是长度放在索引里可不就是越界了吗 | 用for循环里的那个i，然后变量名定义要有意义，长度就用length，不要用i，太容易忘记，然后就有了小bug |

      

   4. 方案2是使用二元数组，这个不太熟悉，并且数组的长度是固定的，后面完全无法扩展，就直接没有考虑。



## 在一个文本文档里写一行英文字符串，统计每个字母出现次数

~~~java
//打开test.txt，里面写字符串，保存关闭
caabab

//共有多少字符数
total：6

//不同的字母有多少个
different_total：3

//结果
'a' : 3
'b' : 2
'c' : 1
~~~

### 思考：

1. 涉及到打开文件，然后读入文件一行内容，读完后关毕文件，java.io文档里查看文件读取相关内容，类的运用

   > 提问：使用字节流好还是字符流好？学习完字节流和字符流的基本操作后，已经大概地明白了操作流程的各个区别，那么在开发中是使用字节流好还是字符流好呢？
   >
   > 回答：使用字节流更好。
   >
   >  
   >
   > 在回答之前，先为读者讲解这样的一个概念，所有的文件在硬盘或在传输时都是以字节的方式进行的，包括图片等都是按字节的方式存储的，而字符是只有在内存中才会形成，所以在开发中，字节流使用较为广泛。

   ![io](../assets/images/java.io 文件内容读取.jpg)

2. 取出一行字符串后，和第一个问题是一样的

   ~~~java
   public static void main(String[] args) {
           // 将反斜线\换成/斜线也可以打开文件，用反斜线\还得转义，就windows文件路径用反斜线
           //String filePath="C:/Users/Lenovo/Desktop/CharactorFrequcyStatistics.txt";
   
           String filePath="C:\\Users\\Lenovo\\Desktop\\CharactorFrequcyStatistics.txt";
           //异常的捕获，必备，手写一个 Excepion 包含所有的
           try{
               FileReader fr=new FileReader(filePath);
               BufferedReader br=new BufferedReader(fr);
               String str=br.readLine();
               System.out.println(str);
               br.close();
               fr.close();
           }catch(Exception e){
               e.printStackTrace();
           }
       }
   //结果
   aaaaaaaa
   ~~~

   

### 代码中涉及到的知识点

| 知识点                                                       | 疑问                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 异常的捕获                                                   | 异常分哪些？                                                 |
| 文件reader和writer都是使用了系统资源，这种资源java不能自动回收，所以需要明确的指令来告诉系统，这个东西我不用了，给其他人用吧。 关闭方法：调用各自的close方法即可。 |                                                              |
| String中斜线的转义，复制文件路径放到双引号里面，自己就多加了一个\ | windows和Linux中的路径斜线格式不一致，就windows文件路径用反斜线 |
| 重用、封装                                                   | 如何复用Main1中的多个方法？                                  |

> Unix使用斜杆/ 作为路径分隔符，而web应用最新使用在Unix系统上面，所以目前所有的网络地址都采用 斜杆/ 作为分隔符。 
>
> Windows由于使用 斜杆/ 作为DOS命令提示符的参数标志了，为了不混淆，所以采用 反斜杠\ 作为路径分隔符。所以目前windows系统上的文件浏览器都是用 反斜杠\ 作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符也用的很少，斜杆和反斜杠在大多数情况下可以互换，没有影响。 
>
> 知道这个背景后，可以总结一下结论： 
>
> （1）浏览器地址栏网址使用 斜杆/ ;  https://www.cnblogs.com/pxh-phper/p/6231294.html
>
> （2）windows文件浏览器上使用 反斜杠\ ; 
>
> （3）出现在html url() 属性中的路径，指定的路径是网络路径，所以必须用 斜杆/ ; 
>
> ```
> <div style="background-image:url(/Image/Control/title.jpg); background-repeat:repeat-x; padding:10px 10px 10px 10px"></div>
> // 如果url后面用反斜杠，就不会显示任何背景
> ```
>
>  （4）出现在普通字符串中的路径，如果代表的是windows文件路径，则使用 斜杆/ 和 反斜杠\ 是一样的；如果代表的是网络文件路径，则必须使用 斜杆/ ; 
>
> ```
> <img src=".\Image/Control/ding.jpg" /> // 本地文件路径，/ 和 \ 是等效的
> <img src="./Image\Control\cai.jpg" />
> <img src="http://hiphotos.baidu.com/yuhua522/pic/item/01a949c67e1023549c163df2.jpg" /> // 网络文件路径，一定要使用 斜杆/
> ```

| 运行时错误                                                   | 解决                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 把Main21里的文件打开读出的str替换为Main1中的str，在try-catch外居然不识别str，说它未声明 | 在异常捕获之前声明一个str的空字符串，在try里str=br.readline()，这样后面就能认出来了。为什么？try-catch难道还是一个函数吗，在里面声明一个str，就只是它的内部变量？ |



## 还是在文本文档里，行数增多

~~~java
//打开test.txt，里面写字符串，保存关闭
caabab
aaaaaa
cccbbb

//共有多少字符数
total：18

//不同的字母有多少个
different_total：3

//结果
'a' : 9
'b' : 5
'c' : 4
~~~

### 思考：

1. 文件读了一行又一行，读一行就往arraylist里进行一次添加和计数，读完了，任务也就完成了
2. 代码时间度量，效率如何？

~~~

~~~



### 代码中包含知识点

| 知识点 | 疑问 |
| ------ | ---- |
|        |      |
|        |      |



| 运行时错误 | 解决方法 |
| ---------- | -------- |
|            |          |
|            |          |



## 将文本文件里的多行字符换成诗句

~~~java
//打开test.txt，里面写诗句，保存关闭
汉皇重色思倾国，御宇多年求不得。
杨家有女初成，养在深闺人未识。
。。。
（全文）
。。。
在天愿做比翼鸟，在地愿做连理枝。
天长地久有时尽，此恨绵绵无绝期。

//共有多少字数
total：840

//不同的字有多少个
different_total：700

//结果
'春' ：10
'君'	：9 
'人'	：6
'六'	：2
~~~



